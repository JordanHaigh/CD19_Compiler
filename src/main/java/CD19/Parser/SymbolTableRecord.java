package CD19.Parser;

import CD19.Parser.Nodes.NodeDataTypes;
import CD19.Scanner.Token;

import java.util.List;
import java.util.Objects;
/**
 * Plain Old Java Object containing symbol table record information
 * Symbol table key is generated by hashing the scope and the lexeme
 *
 * @author Jordan Haigh c3256730
 * @since 29/9/19
 */
public class SymbolTableRecord {
    private int symbolTableKey;

    private String lexeme;
    private String dataType;
    private String scope;

    public SymbolTableRecord(){
        this("",null, "");
    }

    public SymbolTableRecord(String lexeme, String dataType, String scope){
        this.lexeme = lexeme;
        this.dataType = dataType;
        this.scope = scope;
        symbolTableKey = hashCode();
        NodeDataTypes.addDataType(dataType);
    }

    public int getSymbolTableKey() { return symbolTableKey; }
    public String getLexeme() { return lexeme; }
    public String getDataType() { return dataType; }
    public String getScope() { return scope; }


    public List<String> functionVariableTypesAndOrdering;

    public List<String> getFunctionVariableTypesAndOrdering() {
        return functionVariableTypesAndOrdering;
    }

    public void setFunctionVariableTypesAndOrdering(List<String> functionVariableTypesAndOrdering) {
        this.functionVariableTypesAndOrdering = functionVariableTypesAndOrdering;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        SymbolTableRecord that = (SymbolTableRecord) o;
        return dataType == that.dataType &&
                Objects.equals(lexeme, that.lexeme);
    }

    @Override
    public int hashCode() {
        return Objects.hash(lexeme, scope);
    }

}
